// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: tensorflow/core/protobuf/rewriter_config.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Tensorflow {

  /// <summary>Holder for reflection information generated from tensorflow/core/protobuf/rewriter_config.proto</summary>
  public static partial class RewriterConfigReflection {

    #region Descriptor
    /// <summary>File descriptor for tensorflow/core/protobuf/rewriter_config.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static RewriterConfigReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "Ci50ZW5zb3JmbG93L2NvcmUvcHJvdG9idWYvcmV3cml0ZXJfY29uZmlnLnBy",
            "b3RvEgp0ZW5zb3JmbG93IjsKE0F1dG9QYXJhbGxlbE9wdGlvbnMSDgoGZW5h",
            "YmxlGAEgASgIEhQKDG51bV9yZXBsaWNhcxgCIAEoBSKyBQoOUmV3cml0ZXJD",
            "b25maWcSOwoQbGF5b3V0X29wdGltaXplchgBIAEoDjIhLnRlbnNvcmZsb3cu",
            "UmV3cml0ZXJDb25maWcuVG9nZ2xlEjsKEGNvbnN0YW50X2ZvbGRpbmcYAyAB",
            "KA4yIS50ZW5zb3JmbG93LlJld3JpdGVyQ29uZmlnLlRvZ2dsZRJCChdhcml0",
            "aG1ldGljX29wdGltaXphdGlvbhgHIAEoDjIhLnRlbnNvcmZsb3cuUmV3cml0",
            "ZXJDb25maWcuVG9nZ2xlEkIKF2RlcGVuZGVuY3lfb3B0aW1pemF0aW9uGAgg",
            "ASgOMiEudGVuc29yZmxvdy5SZXdyaXRlckNvbmZpZy5Ub2dnbGUSHQoVZGlz",
            "YWJsZV9tb2RlbF9wcnVuaW5nGAIgASgIEkIKE21lbW9yeV9vcHRpbWl6YXRp",
            "b24YBCABKA4yJS50ZW5zb3JmbG93LlJld3JpdGVyQ29uZmlnLk1lbU9wdFR5",
            "cGUSMAoobWVtb3J5X29wdGltaXplcl90YXJnZXRfbm9kZV9uYW1lX3ByZWZp",
            "eBgGIAEoCRI2Cg1hdXRvX3BhcmFsbGVsGAUgASgLMh8udGVuc29yZmxvdy5B",
            "dXRvUGFyYWxsZWxPcHRpb25zEhIKCm9wdGltaXplcnMYZCADKAkiNgoGVG9n",
            "Z2xlEgsKB0RFRkFVTFQQABIGCgJPThABEgcKA09GRhACEg4KCkFHR1JFU1NJ",
            "VkUQAyKEAQoKTWVtT3B0VHlwZRITCg9ERUZBVUxUX01FTV9PUFQQABIOCgpO",
            "T19NRU1fT1BUEAESCgoGTUFOVUFMEAISFwoTU1dBUFBJTkdfSEVVUklTVElD",
            "UxAEEhwKGFJFQ09NUFVUQVRJT05fSEVVUklTVElDUxAFEg4KCkhFVVJJU1RJ",
            "Q1MQA0I1ChhvcmcudGVuc29yZmxvdy5mcmFtZXdvcmtCFFJld3JpdGVyQ29u",
            "ZmlnUHJvdG9zUAH4AQFiBnByb3RvMw=="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { },
          new pbr::GeneratedClrTypeInfo(null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.AutoParallelOptions), global::Tensorflow.AutoParallelOptions.Parser, new[]{ "Enable", "NumReplicas" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.RewriterConfig), global::Tensorflow.RewriterConfig.Parser, new[]{ "LayoutOptimizer", "ConstantFolding", "ArithmeticOptimization", "DependencyOptimization", "DisableModelPruning", "MemoryOptimization", "MemoryOptimizerTargetNodeNamePrefix", "AutoParallel", "Optimizers" }, null, new[]{ typeof(global::Tensorflow.RewriterConfig.Types.Toggle), typeof(global::Tensorflow.RewriterConfig.Types.MemOptType) }, null)
          }));
    }
    #endregion

  }
  #region Messages
  public sealed partial class AutoParallelOptions : pb::IMessage<AutoParallelOptions> {
    private static readonly pb::MessageParser<AutoParallelOptions> _parser = new pb::MessageParser<AutoParallelOptions>(() => new AutoParallelOptions());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<AutoParallelOptions> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Tensorflow.RewriterConfigReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AutoParallelOptions() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AutoParallelOptions(AutoParallelOptions other) : this() {
      enable_ = other.enable_;
      numReplicas_ = other.numReplicas_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AutoParallelOptions Clone() {
      return new AutoParallelOptions(this);
    }

    /// <summary>Field number for the "enable" field.</summary>
    public const int EnableFieldNumber = 1;
    private bool enable_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Enable {
      get { return enable_; }
      set {
        enable_ = value;
      }
    }

    /// <summary>Field number for the "num_replicas" field.</summary>
    public const int NumReplicasFieldNumber = 2;
    private int numReplicas_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int NumReplicas {
      get { return numReplicas_; }
      set {
        numReplicas_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as AutoParallelOptions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(AutoParallelOptions other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Enable != other.Enable) return false;
      if (NumReplicas != other.NumReplicas) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Enable != false) hash ^= Enable.GetHashCode();
      if (NumReplicas != 0) hash ^= NumReplicas.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Enable != false) {
        output.WriteRawTag(8);
        output.WriteBool(Enable);
      }
      if (NumReplicas != 0) {
        output.WriteRawTag(16);
        output.WriteInt32(NumReplicas);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Enable != false) {
        size += 1 + 1;
      }
      if (NumReplicas != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(NumReplicas);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(AutoParallelOptions other) {
      if (other == null) {
        return;
      }
      if (other.Enable != false) {
        Enable = other.Enable;
      }
      if (other.NumReplicas != 0) {
        NumReplicas = other.NumReplicas;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Enable = input.ReadBool();
            break;
          }
          case 16: {
            NumReplicas = input.ReadInt32();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Graph rewriting is experimental and subject to change, not covered by any
  /// API stability guarantees.
  /// </summary>
  public sealed partial class RewriterConfig : pb::IMessage<RewriterConfig> {
    private static readonly pb::MessageParser<RewriterConfig> _parser = new pb::MessageParser<RewriterConfig>(() => new RewriterConfig());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<RewriterConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Tensorflow.RewriterConfigReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RewriterConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RewriterConfig(RewriterConfig other) : this() {
      layoutOptimizer_ = other.layoutOptimizer_;
      constantFolding_ = other.constantFolding_;
      arithmeticOptimization_ = other.arithmeticOptimization_;
      dependencyOptimization_ = other.dependencyOptimization_;
      disableModelPruning_ = other.disableModelPruning_;
      memoryOptimization_ = other.memoryOptimization_;
      memoryOptimizerTargetNodeNamePrefix_ = other.memoryOptimizerTargetNodeNamePrefix_;
      AutoParallel = other.autoParallel_ != null ? other.AutoParallel.Clone() : null;
      optimizers_ = other.optimizers_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RewriterConfig Clone() {
      return new RewriterConfig(this);
    }

    /// <summary>Field number for the "layout_optimizer" field.</summary>
    public const int LayoutOptimizerFieldNumber = 1;
    private global::Tensorflow.RewriterConfig.Types.Toggle layoutOptimizer_ = 0;
    /// <summary>
    /// Optimize tensor layouts
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.RewriterConfig.Types.Toggle LayoutOptimizer {
      get { return layoutOptimizer_; }
      set {
        layoutOptimizer_ = value;
      }
    }

    /// <summary>Field number for the "constant_folding" field.</summary>
    public const int ConstantFoldingFieldNumber = 3;
    private global::Tensorflow.RewriterConfig.Types.Toggle constantFolding_ = 0;
    /// <summary>
    /// Fold constants (default is ON)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.RewriterConfig.Types.Toggle ConstantFolding {
      get { return constantFolding_; }
      set {
        constantFolding_ = value;
      }
    }

    /// <summary>Field number for the "arithmetic_optimization" field.</summary>
    public const int ArithmeticOptimizationFieldNumber = 7;
    private global::Tensorflow.RewriterConfig.Types.Toggle arithmeticOptimization_ = 0;
    /// <summary>
    /// Arithmetic optimizations (default is ON)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.RewriterConfig.Types.Toggle ArithmeticOptimization {
      get { return arithmeticOptimization_; }
      set {
        arithmeticOptimization_ = value;
      }
    }

    /// <summary>Field number for the "dependency_optimization" field.</summary>
    public const int DependencyOptimizationFieldNumber = 8;
    private global::Tensorflow.RewriterConfig.Types.Toggle dependencyOptimization_ = 0;
    /// <summary>
    /// Control dependency optimizations (default is ON).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.RewriterConfig.Types.Toggle DependencyOptimization {
      get { return dependencyOptimization_; }
      set {
        dependencyOptimization_ = value;
      }
    }

    /// <summary>Field number for the "disable_model_pruning" field.</summary>
    public const int DisableModelPruningFieldNumber = 2;
    private bool disableModelPruning_;
    /// <summary>
    /// If true, don't remove unnecessary ops from the graph
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool DisableModelPruning {
      get { return disableModelPruning_; }
      set {
        disableModelPruning_ = value;
      }
    }

    /// <summary>Field number for the "memory_optimization" field.</summary>
    public const int MemoryOptimizationFieldNumber = 4;
    private global::Tensorflow.RewriterConfig.Types.MemOptType memoryOptimization_ = 0;
    /// <summary>
    /// Configures memory optimization passes through the meta-optimizer. Has no
    /// effect on manually requested memory optimization passes in the optimizers
    /// field.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.RewriterConfig.Types.MemOptType MemoryOptimization {
      get { return memoryOptimization_; }
      set {
        memoryOptimization_ = value;
      }
    }

    /// <summary>Field number for the "memory_optimizer_target_node_name_prefix" field.</summary>
    public const int MemoryOptimizerTargetNodeNamePrefixFieldNumber = 6;
    private string memoryOptimizerTargetNodeNamePrefix_ = "";
    /// <summary>
    /// The prefix for nodes which are valid outputs of recomputations. Inputs to
    /// nodes with this name prefix may be recomputed (subject either to manual
    /// annotation of those input nodes or to manual annotation and heuristics
    /// depending on memory_optimization), but the prefixed nodes themselves will
    /// not be recomputed. Typically this will be "gradients/", indicating that
    /// activations from the forward pass of a graph may be recomputed as inputs to
    /// gradients, but may be adjusted if gradients are inside a name scope or if
    /// inputs to non-gradients should be recomputed. Defaults to "gradients/" if
    /// empty or not set.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string MemoryOptimizerTargetNodeNamePrefix {
      get { return memoryOptimizerTargetNodeNamePrefix_; }
      set {
        memoryOptimizerTargetNodeNamePrefix_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "auto_parallel" field.</summary>
    public const int AutoParallelFieldNumber = 5;
    private global::Tensorflow.AutoParallelOptions autoParallel_;
    /// <summary>
    /// Configures AutoParallel optimization passes either through the
    /// meta-optimizer or when manually specified through the optimizers field.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.AutoParallelOptions AutoParallel {
      get { return autoParallel_; }
      set {
        autoParallel_ = value;
      }
    }

    /// <summary>Field number for the "optimizers" field.</summary>
    public const int OptimizersFieldNumber = 100;
    private static readonly pb::FieldCodec<string> _repeated_optimizers_codec
        = pb::FieldCodec.ForString(802);
    private readonly pbc::RepeatedField<string> optimizers_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// If non-empty, will use this as an alternative way to specify a list of
    /// optimizations to turn on and the order of the optimizations (replacing the
    /// meta-optimizer).
    ///
    /// Of the RewriterConfig options, only the AutoParallel configuration options
    /// (the auto_parallel field) apply to manually requested optimization passes
    /// ("autoparallel"). Memory optimization passes ("memory") invoked here are
    /// not configurable (in contrast to memory optimization passes through the
    /// meta-optimizer) and act only on manual op annotations.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> Optimizers {
      get { return optimizers_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as RewriterConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(RewriterConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (LayoutOptimizer != other.LayoutOptimizer) return false;
      if (ConstantFolding != other.ConstantFolding) return false;
      if (ArithmeticOptimization != other.ArithmeticOptimization) return false;
      if (DependencyOptimization != other.DependencyOptimization) return false;
      if (DisableModelPruning != other.DisableModelPruning) return false;
      if (MemoryOptimization != other.MemoryOptimization) return false;
      if (MemoryOptimizerTargetNodeNamePrefix != other.MemoryOptimizerTargetNodeNamePrefix) return false;
      if (!object.Equals(AutoParallel, other.AutoParallel)) return false;
      if(!optimizers_.Equals(other.optimizers_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (LayoutOptimizer != 0) hash ^= LayoutOptimizer.GetHashCode();
      if (ConstantFolding != 0) hash ^= ConstantFolding.GetHashCode();
      if (ArithmeticOptimization != 0) hash ^= ArithmeticOptimization.GetHashCode();
      if (DependencyOptimization != 0) hash ^= DependencyOptimization.GetHashCode();
      if (DisableModelPruning != false) hash ^= DisableModelPruning.GetHashCode();
      if (MemoryOptimization != 0) hash ^= MemoryOptimization.GetHashCode();
      if (MemoryOptimizerTargetNodeNamePrefix.Length != 0) hash ^= MemoryOptimizerTargetNodeNamePrefix.GetHashCode();
      if (autoParallel_ != null) hash ^= AutoParallel.GetHashCode();
      hash ^= optimizers_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (LayoutOptimizer != 0) {
        output.WriteRawTag(8);
        output.WriteEnum((int) LayoutOptimizer);
      }
      if (DisableModelPruning != false) {
        output.WriteRawTag(16);
        output.WriteBool(DisableModelPruning);
      }
      if (ConstantFolding != 0) {
        output.WriteRawTag(24);
        output.WriteEnum((int) ConstantFolding);
      }
      if (MemoryOptimization != 0) {
        output.WriteRawTag(32);
        output.WriteEnum((int) MemoryOptimization);
      }
      if (autoParallel_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(AutoParallel);
      }
      if (MemoryOptimizerTargetNodeNamePrefix.Length != 0) {
        output.WriteRawTag(50);
        output.WriteString(MemoryOptimizerTargetNodeNamePrefix);
      }
      if (ArithmeticOptimization != 0) {
        output.WriteRawTag(56);
        output.WriteEnum((int) ArithmeticOptimization);
      }
      if (DependencyOptimization != 0) {
        output.WriteRawTag(64);
        output.WriteEnum((int) DependencyOptimization);
      }
      optimizers_.WriteTo(output, _repeated_optimizers_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (LayoutOptimizer != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) LayoutOptimizer);
      }
      if (ConstantFolding != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) ConstantFolding);
      }
      if (ArithmeticOptimization != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) ArithmeticOptimization);
      }
      if (DependencyOptimization != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) DependencyOptimization);
      }
      if (DisableModelPruning != false) {
        size += 1 + 1;
      }
      if (MemoryOptimization != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) MemoryOptimization);
      }
      if (MemoryOptimizerTargetNodeNamePrefix.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(MemoryOptimizerTargetNodeNamePrefix);
      }
      if (autoParallel_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(AutoParallel);
      }
      size += optimizers_.CalculateSize(_repeated_optimizers_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(RewriterConfig other) {
      if (other == null) {
        return;
      }
      if (other.LayoutOptimizer != 0) {
        LayoutOptimizer = other.LayoutOptimizer;
      }
      if (other.ConstantFolding != 0) {
        ConstantFolding = other.ConstantFolding;
      }
      if (other.ArithmeticOptimization != 0) {
        ArithmeticOptimization = other.ArithmeticOptimization;
      }
      if (other.DependencyOptimization != 0) {
        DependencyOptimization = other.DependencyOptimization;
      }
      if (other.DisableModelPruning != false) {
        DisableModelPruning = other.DisableModelPruning;
      }
      if (other.MemoryOptimization != 0) {
        MemoryOptimization = other.MemoryOptimization;
      }
      if (other.MemoryOptimizerTargetNodeNamePrefix.Length != 0) {
        MemoryOptimizerTargetNodeNamePrefix = other.MemoryOptimizerTargetNodeNamePrefix;
      }
      if (other.autoParallel_ != null) {
        if (autoParallel_ == null) {
          autoParallel_ = new global::Tensorflow.AutoParallelOptions();
        }
        AutoParallel.MergeFrom(other.AutoParallel);
      }
      optimizers_.Add(other.optimizers_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            layoutOptimizer_ = (global::Tensorflow.RewriterConfig.Types.Toggle) input.ReadEnum();
            break;
          }
          case 16: {
            DisableModelPruning = input.ReadBool();
            break;
          }
          case 24: {
            constantFolding_ = (global::Tensorflow.RewriterConfig.Types.Toggle) input.ReadEnum();
            break;
          }
          case 32: {
            memoryOptimization_ = (global::Tensorflow.RewriterConfig.Types.MemOptType) input.ReadEnum();
            break;
          }
          case 42: {
            if (autoParallel_ == null) {
              autoParallel_ = new global::Tensorflow.AutoParallelOptions();
            }
            input.ReadMessage(autoParallel_);
            break;
          }
          case 50: {
            MemoryOptimizerTargetNodeNamePrefix = input.ReadString();
            break;
          }
          case 56: {
            arithmeticOptimization_ = (global::Tensorflow.RewriterConfig.Types.Toggle) input.ReadEnum();
            break;
          }
          case 64: {
            dependencyOptimization_ = (global::Tensorflow.RewriterConfig.Types.Toggle) input.ReadEnum();
            break;
          }
          case 802: {
            optimizers_.AddEntriesFrom(input, _repeated_optimizers_codec);
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the RewriterConfig message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      public enum Toggle {
        [pbr::OriginalName("DEFAULT")] Default = 0,
        [pbr::OriginalName("ON")] On = 1,
        [pbr::OriginalName("OFF")] Off = 2,
        /// <summary>
        /// Enable some aggressive optimizations that use assumptions that TF graphs
        /// may break. For example, assume the shape of a placeholder matches its
        /// actual feed.
        /// </summary>
        [pbr::OriginalName("AGGRESSIVE")] Aggressive = 3,
      }

      public enum MemOptType {
        /// <summary>
        /// The default setting (currently disabled)
        /// </summary>
        [pbr::OriginalName("DEFAULT_MEM_OPT")] DefaultMemOpt = 0,
        /// <summary>
        /// Disabled in the meta-optimizer.
        /// </summary>
        [pbr::OriginalName("NO_MEM_OPT")] NoMemOpt = 1,
        /// <summary>
        /// Driven by manual op-level annotations.
        /// </summary>
        [pbr::OriginalName("MANUAL")] Manual = 2,
        /// <summary>
        /// Driven by heuristics. The behavior of these heuristics is subject to
        /// change. Currently includes an experimental recomputation and swapping
        /// heuristics. Manual annotations are respected, but additional nodes are
        /// selected automatically.
        /// </summary>
        [pbr::OriginalName("SWAPPING_HEURISTICS")] SwappingHeuristics = 4,
        [pbr::OriginalName("RECOMPUTATION_HEURISTICS")] RecomputationHeuristics = 5,
        /// <summary>
        /// Use any combination of swapping and recomputation heuristics.
        /// </summary>
        [pbr::OriginalName("HEURISTICS")] Heuristics = 3,
      }

    }
    #endregion

  }

  #endregion

}

#endregion Designer generated code
