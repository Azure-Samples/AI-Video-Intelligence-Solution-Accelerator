// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tensorflow/core/protobuf/worker_service.proto
// Original file comments:
// Copyright 2016 The TensorFlow Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ==============================================================================
//
#pragma warning disable 1591
#region Designer generated code

using System;
using System.Threading;
using System.Threading.Tasks;
using grpc = global::Grpc.Core;

namespace Tensorflow.Grpc {
  public static partial class WorkerService
  {
    static readonly string __ServiceName = "tensorflow.grpc.WorkerService";

    static readonly grpc::Marshaller<global::Tensorflow.GetStatusRequest> __Marshaller_GetStatusRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Tensorflow.GetStatusRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Tensorflow.GetStatusResponse> __Marshaller_GetStatusResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Tensorflow.GetStatusResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Tensorflow.CreateWorkerSessionRequest> __Marshaller_CreateWorkerSessionRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Tensorflow.CreateWorkerSessionRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Tensorflow.CreateWorkerSessionResponse> __Marshaller_CreateWorkerSessionResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Tensorflow.CreateWorkerSessionResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Tensorflow.DeleteWorkerSessionRequest> __Marshaller_DeleteWorkerSessionRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Tensorflow.DeleteWorkerSessionRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Tensorflow.DeleteWorkerSessionResponse> __Marshaller_DeleteWorkerSessionResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Tensorflow.DeleteWorkerSessionResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Tensorflow.RegisterGraphRequest> __Marshaller_RegisterGraphRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Tensorflow.RegisterGraphRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Tensorflow.RegisterGraphResponse> __Marshaller_RegisterGraphResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Tensorflow.RegisterGraphResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Tensorflow.DeregisterGraphRequest> __Marshaller_DeregisterGraphRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Tensorflow.DeregisterGraphRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Tensorflow.DeregisterGraphResponse> __Marshaller_DeregisterGraphResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Tensorflow.DeregisterGraphResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Tensorflow.RunGraphRequest> __Marshaller_RunGraphRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Tensorflow.RunGraphRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Tensorflow.RunGraphResponse> __Marshaller_RunGraphResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Tensorflow.RunGraphResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Tensorflow.CleanupGraphRequest> __Marshaller_CleanupGraphRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Tensorflow.CleanupGraphRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Tensorflow.CleanupGraphResponse> __Marshaller_CleanupGraphResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Tensorflow.CleanupGraphResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Tensorflow.CleanupAllRequest> __Marshaller_CleanupAllRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Tensorflow.CleanupAllRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Tensorflow.CleanupAllResponse> __Marshaller_CleanupAllResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Tensorflow.CleanupAllResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Tensorflow.RecvTensorRequest> __Marshaller_RecvTensorRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Tensorflow.RecvTensorRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Tensorflow.RecvTensorResponse> __Marshaller_RecvTensorResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Tensorflow.RecvTensorResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Tensorflow.LoggingRequest> __Marshaller_LoggingRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Tensorflow.LoggingRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Tensorflow.LoggingResponse> __Marshaller_LoggingResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Tensorflow.LoggingResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Tensorflow.TracingRequest> __Marshaller_TracingRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Tensorflow.TracingRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Tensorflow.TracingResponse> __Marshaller_TracingResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Tensorflow.TracingResponse.Parser.ParseFrom);

    static readonly grpc::Method<global::Tensorflow.GetStatusRequest, global::Tensorflow.GetStatusResponse> __Method_GetStatus = new grpc::Method<global::Tensorflow.GetStatusRequest, global::Tensorflow.GetStatusResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "GetStatus",
        __Marshaller_GetStatusRequest,
        __Marshaller_GetStatusResponse);

    static readonly grpc::Method<global::Tensorflow.CreateWorkerSessionRequest, global::Tensorflow.CreateWorkerSessionResponse> __Method_CreateWorkerSession = new grpc::Method<global::Tensorflow.CreateWorkerSessionRequest, global::Tensorflow.CreateWorkerSessionResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "CreateWorkerSession",
        __Marshaller_CreateWorkerSessionRequest,
        __Marshaller_CreateWorkerSessionResponse);

    static readonly grpc::Method<global::Tensorflow.DeleteWorkerSessionRequest, global::Tensorflow.DeleteWorkerSessionResponse> __Method_DeleteWorkerSession = new grpc::Method<global::Tensorflow.DeleteWorkerSessionRequest, global::Tensorflow.DeleteWorkerSessionResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "DeleteWorkerSession",
        __Marshaller_DeleteWorkerSessionRequest,
        __Marshaller_DeleteWorkerSessionResponse);

    static readonly grpc::Method<global::Tensorflow.RegisterGraphRequest, global::Tensorflow.RegisterGraphResponse> __Method_RegisterGraph = new grpc::Method<global::Tensorflow.RegisterGraphRequest, global::Tensorflow.RegisterGraphResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "RegisterGraph",
        __Marshaller_RegisterGraphRequest,
        __Marshaller_RegisterGraphResponse);

    static readonly grpc::Method<global::Tensorflow.DeregisterGraphRequest, global::Tensorflow.DeregisterGraphResponse> __Method_DeregisterGraph = new grpc::Method<global::Tensorflow.DeregisterGraphRequest, global::Tensorflow.DeregisterGraphResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "DeregisterGraph",
        __Marshaller_DeregisterGraphRequest,
        __Marshaller_DeregisterGraphResponse);

    static readonly grpc::Method<global::Tensorflow.RunGraphRequest, global::Tensorflow.RunGraphResponse> __Method_RunGraph = new grpc::Method<global::Tensorflow.RunGraphRequest, global::Tensorflow.RunGraphResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "RunGraph",
        __Marshaller_RunGraphRequest,
        __Marshaller_RunGraphResponse);

    static readonly grpc::Method<global::Tensorflow.CleanupGraphRequest, global::Tensorflow.CleanupGraphResponse> __Method_CleanupGraph = new grpc::Method<global::Tensorflow.CleanupGraphRequest, global::Tensorflow.CleanupGraphResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "CleanupGraph",
        __Marshaller_CleanupGraphRequest,
        __Marshaller_CleanupGraphResponse);

    static readonly grpc::Method<global::Tensorflow.CleanupAllRequest, global::Tensorflow.CleanupAllResponse> __Method_CleanupAll = new grpc::Method<global::Tensorflow.CleanupAllRequest, global::Tensorflow.CleanupAllResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "CleanupAll",
        __Marshaller_CleanupAllRequest,
        __Marshaller_CleanupAllResponse);

    static readonly grpc::Method<global::Tensorflow.RecvTensorRequest, global::Tensorflow.RecvTensorResponse> __Method_RecvTensor = new grpc::Method<global::Tensorflow.RecvTensorRequest, global::Tensorflow.RecvTensorResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "RecvTensor",
        __Marshaller_RecvTensorRequest,
        __Marshaller_RecvTensorResponse);

    static readonly grpc::Method<global::Tensorflow.LoggingRequest, global::Tensorflow.LoggingResponse> __Method_Logging = new grpc::Method<global::Tensorflow.LoggingRequest, global::Tensorflow.LoggingResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "Logging",
        __Marshaller_LoggingRequest,
        __Marshaller_LoggingResponse);

    static readonly grpc::Method<global::Tensorflow.TracingRequest, global::Tensorflow.TracingResponse> __Method_Tracing = new grpc::Method<global::Tensorflow.TracingRequest, global::Tensorflow.TracingResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "Tracing",
        __Marshaller_TracingRequest,
        __Marshaller_TracingResponse);

    /// <summary>Service descriptor</summary>
    public static global::Google.Protobuf.Reflection.ServiceDescriptor Descriptor
    {
      get { return global::Tensorflow.Grpc.WorkerServiceReflection.Descriptor.Services[0]; }
    }

    /// <summary>Base class for server-side implementations of WorkerService</summary>
    public abstract partial class WorkerServiceBase
    {
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Tensorflow.GetStatusResponse> GetStatus(global::Tensorflow.GetStatusRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Tensorflow.CreateWorkerSessionResponse> CreateWorkerSession(global::Tensorflow.CreateWorkerSessionRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Tensorflow.DeleteWorkerSessionResponse> DeleteWorkerSession(global::Tensorflow.DeleteWorkerSessionRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Tensorflow.RegisterGraphResponse> RegisterGraph(global::Tensorflow.RegisterGraphRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Tensorflow.DeregisterGraphResponse> DeregisterGraph(global::Tensorflow.DeregisterGraphRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Tensorflow.RunGraphResponse> RunGraph(global::Tensorflow.RunGraphRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Tensorflow.CleanupGraphResponse> CleanupGraph(global::Tensorflow.CleanupGraphRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Tensorflow.CleanupAllResponse> CleanupAll(global::Tensorflow.CleanupAllRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Tensorflow.RecvTensorResponse> RecvTensor(global::Tensorflow.RecvTensorRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Tensorflow.LoggingResponse> Logging(global::Tensorflow.LoggingRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Tensorflow.TracingResponse> Tracing(global::Tensorflow.TracingRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

    }

    /// <summary>Client for WorkerService</summary>
    public partial class WorkerServiceClient : grpc::ClientBase<WorkerServiceClient>
    {
      /// <summary>Creates a new client for WorkerService</summary>
      /// <param name="channel">The channel to use to make remote calls.</param>
      public WorkerServiceClient(grpc::Channel channel) : base(channel)
      {
      }
      /// <summary>Creates a new client for WorkerService that uses a custom <c>CallInvoker</c>.</summary>
      /// <param name="callInvoker">The callInvoker to use to make remote calls.</param>
      public WorkerServiceClient(grpc::CallInvoker callInvoker) : base(callInvoker)
      {
      }
      /// <summary>Protected parameterless constructor to allow creation of test doubles.</summary>
      protected WorkerServiceClient() : base()
      {
      }
      /// <summary>Protected constructor to allow creation of configured clients.</summary>
      /// <param name="configuration">The client configuration.</param>
      protected WorkerServiceClient(ClientBaseConfiguration configuration) : base(configuration)
      {
      }

      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Tensorflow.GetStatusResponse GetStatus(global::Tensorflow.GetStatusRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return GetStatus(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Tensorflow.GetStatusResponse GetStatus(global::Tensorflow.GetStatusRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_GetStatus, null, options, request);
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Tensorflow.GetStatusResponse> GetStatusAsync(global::Tensorflow.GetStatusRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return GetStatusAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Tensorflow.GetStatusResponse> GetStatusAsync(global::Tensorflow.GetStatusRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_GetStatus, null, options, request);
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Tensorflow.CreateWorkerSessionResponse CreateWorkerSession(global::Tensorflow.CreateWorkerSessionRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return CreateWorkerSession(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Tensorflow.CreateWorkerSessionResponse CreateWorkerSession(global::Tensorflow.CreateWorkerSessionRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_CreateWorkerSession, null, options, request);
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Tensorflow.CreateWorkerSessionResponse> CreateWorkerSessionAsync(global::Tensorflow.CreateWorkerSessionRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return CreateWorkerSessionAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Tensorflow.CreateWorkerSessionResponse> CreateWorkerSessionAsync(global::Tensorflow.CreateWorkerSessionRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_CreateWorkerSession, null, options, request);
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Tensorflow.DeleteWorkerSessionResponse DeleteWorkerSession(global::Tensorflow.DeleteWorkerSessionRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return DeleteWorkerSession(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Tensorflow.DeleteWorkerSessionResponse DeleteWorkerSession(global::Tensorflow.DeleteWorkerSessionRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_DeleteWorkerSession, null, options, request);
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Tensorflow.DeleteWorkerSessionResponse> DeleteWorkerSessionAsync(global::Tensorflow.DeleteWorkerSessionRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return DeleteWorkerSessionAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Tensorflow.DeleteWorkerSessionResponse> DeleteWorkerSessionAsync(global::Tensorflow.DeleteWorkerSessionRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_DeleteWorkerSession, null, options, request);
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Tensorflow.RegisterGraphResponse RegisterGraph(global::Tensorflow.RegisterGraphRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return RegisterGraph(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Tensorflow.RegisterGraphResponse RegisterGraph(global::Tensorflow.RegisterGraphRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_RegisterGraph, null, options, request);
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Tensorflow.RegisterGraphResponse> RegisterGraphAsync(global::Tensorflow.RegisterGraphRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return RegisterGraphAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Tensorflow.RegisterGraphResponse> RegisterGraphAsync(global::Tensorflow.RegisterGraphRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_RegisterGraph, null, options, request);
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Tensorflow.DeregisterGraphResponse DeregisterGraph(global::Tensorflow.DeregisterGraphRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return DeregisterGraph(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Tensorflow.DeregisterGraphResponse DeregisterGraph(global::Tensorflow.DeregisterGraphRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_DeregisterGraph, null, options, request);
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Tensorflow.DeregisterGraphResponse> DeregisterGraphAsync(global::Tensorflow.DeregisterGraphRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return DeregisterGraphAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Tensorflow.DeregisterGraphResponse> DeregisterGraphAsync(global::Tensorflow.DeregisterGraphRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_DeregisterGraph, null, options, request);
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Tensorflow.RunGraphResponse RunGraph(global::Tensorflow.RunGraphRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return RunGraph(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Tensorflow.RunGraphResponse RunGraph(global::Tensorflow.RunGraphRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_RunGraph, null, options, request);
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Tensorflow.RunGraphResponse> RunGraphAsync(global::Tensorflow.RunGraphRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return RunGraphAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Tensorflow.RunGraphResponse> RunGraphAsync(global::Tensorflow.RunGraphRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_RunGraph, null, options, request);
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Tensorflow.CleanupGraphResponse CleanupGraph(global::Tensorflow.CleanupGraphRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return CleanupGraph(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Tensorflow.CleanupGraphResponse CleanupGraph(global::Tensorflow.CleanupGraphRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_CleanupGraph, null, options, request);
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Tensorflow.CleanupGraphResponse> CleanupGraphAsync(global::Tensorflow.CleanupGraphRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return CleanupGraphAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Tensorflow.CleanupGraphResponse> CleanupGraphAsync(global::Tensorflow.CleanupGraphRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_CleanupGraph, null, options, request);
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Tensorflow.CleanupAllResponse CleanupAll(global::Tensorflow.CleanupAllRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return CleanupAll(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Tensorflow.CleanupAllResponse CleanupAll(global::Tensorflow.CleanupAllRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_CleanupAll, null, options, request);
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Tensorflow.CleanupAllResponse> CleanupAllAsync(global::Tensorflow.CleanupAllRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return CleanupAllAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Tensorflow.CleanupAllResponse> CleanupAllAsync(global::Tensorflow.CleanupAllRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_CleanupAll, null, options, request);
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Tensorflow.RecvTensorResponse RecvTensor(global::Tensorflow.RecvTensorRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return RecvTensor(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Tensorflow.RecvTensorResponse RecvTensor(global::Tensorflow.RecvTensorRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_RecvTensor, null, options, request);
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Tensorflow.RecvTensorResponse> RecvTensorAsync(global::Tensorflow.RecvTensorRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return RecvTensorAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Tensorflow.RecvTensorResponse> RecvTensorAsync(global::Tensorflow.RecvTensorRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_RecvTensor, null, options, request);
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Tensorflow.LoggingResponse Logging(global::Tensorflow.LoggingRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return Logging(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Tensorflow.LoggingResponse Logging(global::Tensorflow.LoggingRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_Logging, null, options, request);
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Tensorflow.LoggingResponse> LoggingAsync(global::Tensorflow.LoggingRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return LoggingAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Tensorflow.LoggingResponse> LoggingAsync(global::Tensorflow.LoggingRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_Logging, null, options, request);
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Tensorflow.TracingResponse Tracing(global::Tensorflow.TracingRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return Tracing(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Tensorflow.TracingResponse Tracing(global::Tensorflow.TracingRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_Tracing, null, options, request);
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Tensorflow.TracingResponse> TracingAsync(global::Tensorflow.TracingRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return TracingAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// See worker.proto for details.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Tensorflow.TracingResponse> TracingAsync(global::Tensorflow.TracingRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_Tracing, null, options, request);
      }
      /// <summary>Creates a new instance of client from given <c>ClientBaseConfiguration</c>.</summary>
      protected override WorkerServiceClient NewInstance(ClientBaseConfiguration configuration)
      {
        return new WorkerServiceClient(configuration);
      }
    }

    /// <summary>Creates service definition that can be registered with a server</summary>
    /// <param name="serviceImpl">An object implementing the server-side handling logic.</param>
    public static grpc::ServerServiceDefinition BindService(WorkerServiceBase serviceImpl)
    {
      return grpc::ServerServiceDefinition.CreateBuilder()
          .AddMethod(__Method_GetStatus, serviceImpl.GetStatus)
          .AddMethod(__Method_CreateWorkerSession, serviceImpl.CreateWorkerSession)
          .AddMethod(__Method_DeleteWorkerSession, serviceImpl.DeleteWorkerSession)
          .AddMethod(__Method_RegisterGraph, serviceImpl.RegisterGraph)
          .AddMethod(__Method_DeregisterGraph, serviceImpl.DeregisterGraph)
          .AddMethod(__Method_RunGraph, serviceImpl.RunGraph)
          .AddMethod(__Method_CleanupGraph, serviceImpl.CleanupGraph)
          .AddMethod(__Method_CleanupAll, serviceImpl.CleanupAll)
          .AddMethod(__Method_RecvTensor, serviceImpl.RecvTensor)
          .AddMethod(__Method_Logging, serviceImpl.Logging)
          .AddMethod(__Method_Tracing, serviceImpl.Tracing).Build();
    }

  }
}
#endregion
